<html lang="en">
	<head>
		<link href="style.css" rel="stylesheet" type="text/css" />
		<link href="reset.css" rel="stylesheet" type="text/css" />

		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<meta charset="utf-8">
	</head>
	<body>
		<noscript>
			You must have javascript
		</noscript>

		<div id="top-bar">

		</div>
		<div id="side-bar">

		</div>
		<div id="viewport">

		</div>

		<script type="text/javascript">
			var top, side, vp;

			var group;
			var container;
			var stats;
			var particlesData = [];
			var camera;
			var scene;
			var renderer;
			var positions;
			var colors;
			var pointCloud;
			var particlePositions;
			var linesMesh;

			var camDist = 50;

			var maxParticleCount = 1000;
			var particleCount = 500;
			var r = 800;
			var rHalf = r / 2;

			var effectController = {
				showDots: false,
				showLines: true,
				minDistance: 75,
				limitConnections: true,
				maxConnections: 5,
				particleCount: 750
			}

			var width = window.innerWidth;
			var height = window.innerHeight;

			init();
			animate();

			function initGUI()
			{
				var top = document.getElementById("top-bar");
				var topHeight = 20;
				var side = document.getElementById("side-bar");
				var sideWidth = 200;
				var vp = document.getElementById("viewport");

				top.style.width = width;
				top.style.height = topHeight;
				top.style.top = 0;
				top.style.left = 0;

				side.style.width = sideWidth;
				side.style.height = height - parseInt(top.style.height, 10);
				side.style.top = parseInt(top.style.height, 10);
				side.style.left = 0;

				vp.style.width = width - parseInt(side.style.width, 10);
				vp.style.height = height - parseInt(top.style.height, 10);
				vp.style.top = parseInt(top.style.height, 10);
				vp.style.left = parseInt(side.style.width, 10);

				var gui = new dat.GUI();

				gui.add( effectController, "showDots" ).onChange( function( value ) { pointCloud.visible = value; } );
				gui.add( effectController, "showLines" ).onChange( function( value ) { linesMesh.visible = value; } );
				gui.add( effectController, "minDistance", 10, 300 );
				gui.add( effectController, "limitConnections" );
				gui.add( effectController, "maxConnections", 0, 30, 1 );
				gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).onChange( function( value ) {

					particleCount = parseInt( value );
					particles.drawcalls[ 0 ].count = particleCount;

				});
			}

			function init()
			{
				initGUI();

				container = document.getElementById("viewport");

				camera = new THREE.PerspectiveCamera(45, width / height, 10, 10000);
				camera.position.z = camDist;

				controls = new THREE.OrbitControls(camera, container);

				scene = new THREE.Scene();

				group = new THREE.Group();
				scene.add(group);

				var helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
				helper.material.color.setHex(0x080808);
				helper.material.blending = THREE.AdditiveBlending;
				helper.material.transparent = true;
				group.add(helper);

				var segments = maxParticleCount * maxParticleCount;

				positions = new Float32Array(segments * 3);
				colors = new Float32Array(segments * 3);

				var pMaterial = new THREE.PointCloudMaterial(
					{
						color:0xffffff,
						size:3,
						blending:THREE.AdditiveBlending,
						transparent:true,
						sizeAttentuation:false
					}
				);

				particles = new THREE.BufferGeometry();
				particlePositions = new Float32Array(maxParticleCount * 3);

				for(var i = 0; i < maxParticleCount; i++)
				{
					var x = Math.random() * r - (r / 2);
					var y = Math.random() * r - (r / 2);
					var z = Math.random() * r - (r / 2);

					particlePositions[i * 3] = x;
					particlePositions[i * 3 + 1] = y;
					particlePositions[i * 3 + 2] = z;

					particlesData.push(
						{
							velocity:new THREE.Vector3(-2 + Math.random() * 4, -2 + Math.random() * 4, -2 + Math.random() * 4),
							numConnections:0
						}
					);
				}

				particles.drawcalls.push(
					{
						start:0,
						count:particleCount,
						index:0
					}
				);

				particles.addAttribute("position", new THREE.DynamicBufferAttribute(particlePositions, 3));

				pointCloud = new THREE.PointCloud(particles, pMaterial);
				group.add(pointCloud);

				var geometry = new THREE.BufferGeometry();

				geometry.addAttribute("position", new THREE.DynamicBufferAttribute(positions, 3));
				geometry.addAttribute("color", new THREE.DynamicBufferAttribute(colors, 3));

				geometry.computeBoundingSphere();

				geometry.drawcalls.push(
					{
						start:0,
						count:0,
						index:0
					}
				);

				var material = new THREE.LineBasicMaterial( {
					vertexColors:THREE.VertexColors,
					blending:THREE.AdditiveBlending,
					transparent:true
				});

				linesMesh = new THREE.Line( geometry, material, THREE.LinePieces);
				group.add(linesMesh);

				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(vpWidth(), vpHeight());
				renderer.setClearColor(0x345678);

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild(renderer.domElement);

				window.addEventListener("resize", windowResize, false);
			}

			function animate()
			{
				var vertexpos = 0;
				var colorpos = 0;
				var numConnected = 0;

				for (var i = 0; i < particleCount; i++)
					particlesData[i].numConnections = 0
				for (var i = 0; i < particleCount; i++) {

					var particleData = particlesData[i];

					particlePositions[i*3] += particleData.velocity.x;
					particlePositions[i*3+1] += particleData.velocity.y;
					particlePositions[i*3+2] += particleData.velocity.z;

					if ( particlePositions[i*3] < -rHalf || particlePositions[i*3] > rHalf)
						particleData.velocity.x = -particleData.velocity.x;
					if ( particlePositions[i*3+1] < -rHalf || particlePositions[i*3+1] > rHalf)
						particleData.velocity.y = -particleData.velocity.y;
					if ( particlePositions[i*3+2] < -rHalf || particlePositions[i*3+2] > rHalf)
						particleData.velocity.z = -particleData.velocity.z;

					if (effectController.limitConnections && particleData.numConnections >= effectController.maxConnections)
						continue;

					for (var j=i+1; j<particleCount;j++) {
						var particleDataCompare = particlesData[j];
						if (effectController.limitConnections && particleDataCompare.numConnections >= effectController.maxConnections)
							continue;

						var dx = particlePositions[i*3]-particlePositions[j*3];
						var dy = particlePositions[i*3+1]-particlePositions[j*3+1];
						var dz = particlePositions[i*3+2]-particlePositions[j*3+2];
						var dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

						if (dist < effectController.minDistance) {

							particleData.numConnections++;
							particleDataCompare.numConnections++;

							var alpha = 1.0 - dist / effectController.minDistance;

							positions[ vertexpos++ ] = particlePositions[i*3];
							positions[ vertexpos++ ] = particlePositions[i*3+1];
							positions[ vertexpos++ ] = particlePositions[i*3+2];
							positions[ vertexpos++ ] = particlePositions[j*3];
							positions[ vertexpos++ ] = particlePositions[j*3+1];
							positions[ vertexpos++ ] = particlePositions[j*3+2];

							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;
							colors[ colorpos++ ] = alpha;

							numConnected++;
						}
					}
				}

				linesMesh.geometry.drawcalls[0].count = numConnected *2;
				linesMesh.geometry.attributes.position.needsUpdate = true;
				linesMesh.geometry.attributes.color.needsUpdate = true;

				pointCloud.geometry.attributes.position.needsUpdate = true;

				requestAnimationFrame(animate);

				render();
			}

			function render()
			{
				var time = Date.now() * 0.001;
				group.rotation.y = time * (3 * Math.PI / 16);
				renderer.render(scene, camera);
			}

			function vpWidth()
			{
				var vp = document.getElementById("viewport");
				return (parseInt(vp.style.width, 10));
			}

			function vpHeight()
			{
				var vp = document.getElementById("viewport");
				return (parseInt(vp.style.height, 10));
			}

			function vpSetWidth(w)
			{
				console.log("set wdth: " + w);
				var vp = document.getElementById("viewport");
				vp.style.width = w;
			}

			function vpSetHeight(h)
			{
				console.log("set hight: " + h);
				var vp = document.getElementById("viewport");
				vp.style.height = h;
			}

			function windowResize()
			{
				camera.aspect = width/height;
				camera.updateProjectionMatrix();
				width = window.innerWidth;
				height = window.innerHeight;
				vpSetWidth(width);
				vpSetHeight(height);
				console.log('doin it')
				renderer.setSize(vpWidth(), vpHeight());
			}

			window.oncontextmenu = function()
			{
				// Prevent context menu opening
				return false;
			}

			window.onmousemove = function(event)
			{
				// Capture mouse move
			}

			window.onmousedown = function(event)
			{
				// Capture mouse down
			}

			window.onmouseup = function(event)
			{
				// Capture mouse up
			}

			window.onmousewheel = function(event)
			{
				// Capture mouse wheel
			}

		</script>
	</body>
</html>
